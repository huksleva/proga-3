# Лабораторная работа №3

## Описание

Данный проект реализует генерацию бинарного дерева с использованием рекурсивного алгоритма и предоставляет инструменты для его визуализации и тестирования. Дерево представляется в виде словаря, где ключи соответствуют индексам узлов в представлении полной бинарной кучи (heap), а значения — вычисляемым данным узлов.

---

## Структура проекта

- `code.py` — основной модуль с функциями генерации и отображения дерева
- `test.py` — модуль для автоматизированного тестирования

---

## Функции

### `gen_bin_tree(root, height, i=0, dictionary=None)`

**Назначение**:  
Рекурсивно генерирует бинарное дерево заданной высоты и возвращает его в виде словаря.

**Параметры**:
- `root` (int): значение корневого узла
- `height` (int): высота дерева (при `height = 0` дерево пустое)
- `i` (int, опционально): текущий индекс узла в представлении кучи (используется для рекурсии)
- `dictionary` (dict или None, опционально): словарь для накопления результатов (не должен передаваться вручную)

**Возвращает**:  
`dict` — словарь вида `{индекс: значение}`, где:
- индекс `0` — корень,
- для узла с индексом `i`:  
  - левый потомок имеет индекс `2*i + 1`,  
  - правый потомок — `2*i + 2`.

**Правила вычисления значений**:
- Левый потомок: `root * 2`
- Правый потомок: `root + 3`

**Пример**:
```python
gen_bin_tree(1, 3)
# Результат: {0: 1, 1: 2, 2: 4, 3: 4, 4: 5, 5: 8, 6: 7}
```

---

### `print_heap_tree(tree_dict, index=0, prefix="", is_last=True)`

**Назначение**:  
Красиво выводит бинарное дерево в консоль в виде иерархической структуры с ветвями.

**Параметры**:
- `tree_dict` (dict): словарь, сгенерированный функцией `gen_bin_tree`
- `index` (int): текущий индекс узла (по умолчанию `0` — корень)
- `prefix` (str): строка отступов для текущего уровня (для внутреннего использования)
- `is_last` (bool): флаг, указывающий, является ли узел последним у своего родителя

**Вывод**:  
Дерево в консоли в формате:
```
└── 1
    ├── 2
    │   ├── 4
    │   └── 5
    └── 4
        ├── 8
        └── 7
```

---

## Тестирование

Файл `test.py` содержит модульные тесты с использованием библиотеки `unittest`.

### Класс `Test`

#### Метод `test1`
- Проверяет, что результат `gen_bin_tree(1, 5)`:
  - Является объектом типа `dict`
  - Точно соответствует ожидаемому словарю с 31 элементом

**Ожидаемый результат**:
```python
{
  0: 1, 1: 2, 2: 4, 3: 4, 4: 5, 5: 8, 6: 7,
  7: 8, 8: 7, 9: 10, 10: 8, 11: 16, 12: 11, 13: 14, 14: 10,
  15: 16, 16: 11, 17: 14, 18: 10, 19: 20, 20: 13, 21: 16, 22: 11,
  23: 32, 24: 19, 25: 22, 26: 14, 27: 28, 28: 17, 29: 20, 30: 13
}
```

> ✅ Тест гарантирует корректность алгоритма генерации дерева.

---

## Листинг кода
1. **code.py**:
```python
def gen_bin_tree(root, height, i=0, dictionary=None):
    if height == 0:
        return None

    dictionary.update({i: root})


    l = i * 2 + 1
    r = i * 2 + 2

    left_leaf = root * 2
    right_leaf = root + 3

    gen_bin_tree(left_leaf, height - 1, l, dictionary)
    gen_bin_tree(right_leaf, height - 1, r, dictionary)

    return dictionary


def print_heap_tree(tree_dict, index=0, prefix="", is_last=True):
    """
    Красиво выводит бинарное дерево, представленное словарём по индексам кучи.

    tree_dict: dict, где ключи — индексы узлов (0, 1, 2, ...), значения — данные узлов.
    index: текущий индекс (по умолчанию 0 — корень)
    prefix: строка отступов для текущего уровня
    is_last: является ли узел последним у родителя (для правильного рисования ветвей)
    """
    if index not in tree_dict:
        return

    # Определяем символы ветвей
    branch = "└── " if is_last else "├── "
    print(prefix + branch + str(tree_dict[index]))

    # Вычисляем индексы потомков
    left = 2 * index + 1
    right = 2 * index + 2

    # Проверяем, существуют ли потомки
    has_left = left in tree_dict
    has_right = right in tree_dict

    # Новый префикс для потомков
    new_prefix = prefix + ("    " if is_last else "│   ")

    # Рекурсивно выводим потомков
    if has_left or has_right:
        # Левый потомок (всегда первый)
        if has_left:
            print_heap_tree(tree_dict, left, new_prefix, not has_right)
        # Правый потомок
        if has_right:
            print_heap_tree(tree_dict, right, new_prefix, True)


root = 1
height = 5
# print(gen_bin_tree(root, height))
# print_heap_tree(gen_bin_tree(root, height))
```

2. **test.py**:
```python
import unittest
from code import gen_bin_tree


class Test(unittest.TestCase):

    def test1(self):
        root = 1
        height = 5
        d = gen_bin_tree(root, height)
        self.assertIsInstance(d, dict)
        self.assertEqual(d, {0: 1, 1: 2, 3: 4, 7: 8, 15: 16, 16: 11, 8: 7, 17: 14, 18: 10, 4: 5, 9: 10, 19: 20, 20: 13, 10: 8, 21: 16, 22: 11, 2: 4, 5: 8, 11: 16, 23: 32, 24: 19, 12: 11, 25: 22, 26: 14, 6: 7, 13: 14, 27: 28, 28: 17, 14: 10, 29: 20, 30: 13})
```

3. **Запуск тестов**:
   ```bash
   python -m unittest test.py
   ```

---

## Примечания

- Дерево строится по **индексной схеме кучи**, что позволяет однозначно определить структуру по ключам словаря.
- Функция `gen_bin_tree` использует **рекурсию** и **глубину дерева** как критерий остановки.
- Для корректной работы **не следует передавать параметр `dictionary` вручную** — он предназначен только для внутреннего использования при рекурсии.

---

## Возможные улучшения

- Добавить параметризацию правил вычисления потомков (для поддержки разных вариантов задания)
- Реализовать проверку на переполнение при больших высотах
- Добавить экспорт дерева в JSON или другие форматы

--- 
